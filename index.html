<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VOX UMBREA MK-III: DAEMON EDITION</title>
    <style>
        :root {
            --bg: #020202;
            --panel: #0f0f0f;
            --border: #333;
            --cyan: #00f3ff;
            --magenta: #ff0055;
            --gold: #ffcc00;
            --text: #c0c0c0;
            --font: 'Courier New', monospace;
        }

        body {
            background-color: var(--bg);
            color: var(--text);
            font-family: var(--font);
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
            user-select: none;
        }

        /* --- VISUALIZADOR (EL OJO) --- */
        #visualizer-container {
            height: 120px;
            background: #000;
            border-bottom: 1px solid var(--cyan);
            position: relative;
        }
        canvas { width: 100%; height: 100%; display: block; }
        .hud-text {
            position: absolute;
            top: 5px; left: 10px;
            font-size: 0.7rem;
            color: var(--cyan);
            opacity: 0.7;
        }

        /* --- CONTROLES GLOBALES --- */
        header {
            padding: 10px;
            background: var(--panel);
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        button {
            background: #000;
            border: 1px solid var(--cyan);
            color: var(--cyan);
            padding: 8px 20px;
            font-family: inherit;
            font-weight: bold;
            cursor: pointer;
            text-transform: uppercase;
            box-shadow: 0 0 5px rgba(0, 243, 255, 0.2);
            transition: all 0.2s;
        }
        button:hover { background: var(--cyan); color: #000; }
        button.active { background: var(--magenta); border-color: var(--magenta); color: #fff; }

        input[type=range] { accent-color: var(--magenta); cursor: pointer; }

        /* --- SECUENCIADOR --- */
        #sequencer {
            padding: 15px;
            flex: 0 0 auto;
            border-bottom: 1px dashed var(--border);
        }
        .track { display: flex; align-items: center; margin-bottom: 8px; }
        .label { width: 80px; font-size: 0.7rem; color: var(--gold); letter-spacing: 1px;}
        .steps { display: flex; gap: 4px; flex: 1; }
        .step {
            flex: 1; height: 25px;
            background: #1a1a1a;
            border: 1px solid #333;
            cursor: pointer;
        }
        .step.on { background: var(--gold); box-shadow: 0 0 8px var(--gold); border-color: #fff; }
        .step.trigger { transform: scale(1.1); filter: brightness(1.5); }

        /* --- MEZCLADORA & FX --- */
        #mixer-deck {
            flex: 1;
            display: flex;
            padding: 10px;
            gap: 15px;
            background: #080808;
        }

        .deck-col {
            flex: 1;
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 10px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            background: rgba(255,255,255,0.02);
        }
        .deck-title { color: var(--magenta); font-size: 0.8rem; border-bottom: 1px solid #333; padding-bottom: 5px; }

        .knob-panel {
            display: flex;
            flex-direction: column;
            gap: 5px;
            margin-top: auto;
            padding-top: 10px;
            border-top: 1px solid #333;
        }
        .small-label { font-size: 0.6rem; color: #666; }

        /* --- CROSSFADER ZONE --- */
        #master-fx {
            padding: 15px;
            background: var(--panel);
            border-top: 1px solid var(--cyan);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 20px;
        }
        #xfader { width: 200px; }

    </style>
</head>
<body>

    <div id="visualizer-container">
        <div class="hud-text">:: ANALIZADOR ESPECTRAL // KERNEL: ACTIVO ::</div>
        <canvas id="scope"></canvas>
    </div>

    <header>
        <div>
            <button id="pwrBtn" onclick="toggleSystem()">INICIAR SISTEMA</button>
            <span style="margin-left:10px; font-size:0.8rem; color:#666;" id="status">ESPERANDO...</span>
        </div>
        <div style="display:flex; align-items:center; gap:10px;">
            <label class="small-label">TEMPO (BPM)</label>
            <input type="range" min="60" max="160" value="95" oninput="updateBPM(this.value)">
            <span id="bpmDisplay" style="width:30px; text-align:right; font-size:0.8rem;">95</span>
        </div>
    </header>

    <div id="sequencer">
        <div class="track">
            <div class="label">KICK</div>
            <div class="steps" id="row-kick"></div>
        </div>
        <div class="track">
            <div class="label">SNARE</div>
            <div class="steps" id="row-snare"></div>
        </div>
        <div class="track">
            <div class="label">HIHAT</div>
            <div class="steps" id="row-hihat"></div>
        </div>
        <div class="track">
            <div class="label" style="color:var(--cyan)">BASS (FM)</div>
            <div class="steps" id="row-bass"></div>
        </div>
    </div>

    <div id="mixer-deck">
        <!-- DECK A -->
        <div class="deck-col">
            <div class="deck-title">DECK A [CUMBIA/ROOTS]</div>
            <input type="file" accept="audio/*" onchange="loadDeck('A', this)" style="font-size:0.7rem;">
            <button onclick="toggleDeck('A')">PLAY / STOP</button>

            <div class="knob-panel">
                <span class="small-label">FILTRO (LPF)</span>
                <input type="range" min="0" max="100" value="100" oninput="setFilter('A', this.value)">
            </div>
        </div>

        <!-- FX RACK -->
        <div class="deck-col" style="flex: 0.5; border-color: var(--cyan);">
            <div class="deck-title" style="color:var(--cyan)">FX: DUB ECHO</div>
            <div class="knob-panel" style="border:none;">
                <span class="small-label">TIEMPO (DELAY)</span>
                <input type="range" min="0" max="100" value="30" oninput="setDelayTime(this.value)">
                <span class="small-label">FEEDBACK</span>
                <input type="range" min="0" max="90" value="40" oninput="setDelayFeedback(this.value)">
                <span class="small-label">ENVÍO (WET)</span>
                <input type="range" min="0" max="100" value="0" oninput="setDelayWet(this.value)">
            </div>
        </div>

        <!-- DECK B -->
        <div class="deck-col">
            <div class="deck-title">DECK B [HIPHOP/TRAP]</div>
            <input type="file" accept="audio/*" onchange="loadDeck('B', this)" style="font-size:0.7rem;">
            <button onclick="toggleDeck('B')">PLAY / STOP</button>

            <div class="knob-panel">
                <span class="small-label">FILTRO (HPF)</span>
                <input type="range" min="0" max="100" value="0" oninput="setFilter('B', this.value)">
            </div>
        </div>
    </div>

    <div id="master-fx">
        <span style="color:var(--gold); font-size:0.8rem;">A</span>
        <input type="range" id="xfader" min="0" max="100" value="50" oninput="crossfade(this.value)">
        <span style="color:var(--magenta); font-size:0.8rem;">B</span>
    </div>

    <script>
        // --- NÚCLEO DEL AUDIO ---
        const AudioContext = window.AudioContext || window.webkitAudioContext;
        let ctx;
        let masterGain;
        let compressor;
        let analyser;

        // --- BUS DE EFECTOS (DELAY) ---
        let delayNode, feedbackNode, wetGainNode;

        // --- ESTADO ---
        let isRunning = false;
        let bpm = 95;
        let currentStep = 0;
        let nextNoteTime = 0;
        let timerID;
        const lookahead = 25.0;
        const scheduleAheadTime = 0.1;

        // --- DATOS DE SECUENCIA ---
        const tracks = ['kick', 'snare', 'hihat', 'bass'];
        const pattern = {
            kick:  [1,0,0,0, 1,0,0,0, 1,0,0,0, 1,0,0,0],
            snare: [0,0,1,0, 0,0,1,0, 0,0,1,0, 0,0,1,0],
            hihat: [1,1,1,1, 1,1,1,1, 1,1,1,1, 1,1,1,1],
            bass:  [1,0,0,1, 0,0,1,0, 1,0,0,1, 0,1,0,0]
        };

        // --- INICIALIZACIÓN ---
        function initAudio() {
            if(ctx) return;
            ctx = new AudioContext();

            // Cadena Master: Master -> Compressor -> Analyser -> Destination
            masterGain = ctx.createGain();
            compressor = ctx.createDynamicsCompressor();
            compressor.threshold.setValueAtTime(-24, ctx.currentTime);
            compressor.knee.setValueAtTime(30, ctx.currentTime);
            compressor.ratio.setValueAtTime(12, ctx.currentTime);

            analyser = ctx.createAnalyser();
            analyser.fftSize = 256;

            masterGain.connect(compressor);
            compressor.connect(analyser);
            analyser.connect(ctx.destination);

            // Configurar FX (Dub Delay)
            delayNode = ctx.createDelay();
            delayNode.delayTime.value = 0.3; // Tiempo inicial
            feedbackNode = ctx.createGain();
            feedbackNode.gain.value = 0.4;
            wetGainNode = ctx.createGain();
            wetGainNode.gain.value = 0.0; // Apagado por defecto

            // Ruteo del Delay: Envío Auxiliar
            // Master -> WetGain -> Delay -> Feedback -> Delay
            // Delay -> Master (Retorno)
            // *Simplificación para este código*: Conectaremos los instrumentos al DelaySend

            // Vamos a crear un bus de envios global
            window.fxBus = ctx.createGain();
            window.fxBus.connect(wetGainNode);
            wetGainNode.connect(delayNode);
            delayNode.connect(feedbackNode);
            feedbackNode.connect(delayNode);
            delayNode.connect(masterGain); // El eco vuelve al master

            initDecks();
            visualize();
        }

        function toggleSystem() {
            if(!ctx) initAudio();
            if(ctx.state === 'suspended') ctx.resume();

            isRunning = !isRunning;
            const btn = document.getElementById('pwrBtn');
            const status = document.getElementById('status');

            if(isRunning) {
                btn.classList.add('active');
                btn.innerText = "DETENER SISTEMA";
                status.innerText = "SECUENCIADOR: CORRIENDO";
                currentStep = 0;
                nextNoteTime = ctx.currentTime;
                scheduler();
            } else {
                btn.classList.remove('active');
                btn.innerText = "INICIAR SISTEMA";
                status.innerText = "SISTEMA EN ESPERA";
                clearTimeout(timerID);
            }
        }

        // --- MOTOR DEL SECUENCIADOR ---
        function nextNote() {
            const secondsPerBeat = 60.0 / bpm;
            nextNoteTime += 0.25 * secondsPerBeat; // Semicorcheas (16th)
            currentStep = (currentStep + 1) % 16;
        }

        function scheduleNote(step, time) {
            // UI Sync
            requestAnimationFrame(() => {
                document.querySelectorAll('.step').forEach(s => s.classList.remove('trigger'));
                tracks.forEach(t => {
                    const el = document.getElementById(`${t}-${step}`);
                    if(el) el.classList.add('trigger');
                });
            });

            // Audio Trigger
            if(pattern.kick[step]) playDrum('kick', time);
            if(pattern.snare[step]) playDrum('snare', time);
            if(pattern.hihat[step]) playDrum('hihat', time);
            if(pattern.bass[step]) playBass(time, step); // Nuevo Synth
        }

        function scheduler() {
            while (nextNoteTime < ctx.currentTime + scheduleAheadTime) {
                scheduleNote(currentStep, nextNoteTime);
                nextNote();
            }
            timerID = setTimeout(scheduler, lookahead);
        }

        // --- SINTETIZADORES MEJORADOS ---
        function playDrum(type, time) {
            const osc = ctx.createOscillator();
            const gain = ctx.createGain();

            // Envío al Master y al FX Bus
            gain.connect(masterGain);
            gain.connect(window.fxBus); // Enviar a delay

            if(type === 'kick') {
                osc.frequency.setValueAtTime(150, time);
                osc.frequency.exponentialRampToValueAtTime(0.01, time + 0.5);
                gain.gain.setValueAtTime(1, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.5);
            } else if (type === 'snare') {
                osc.type = 'triangle';
                osc.frequency.setValueAtTime(250, time);
                gain.gain.setValueAtTime(0.7, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.2);
                // Ruido blanco adicional para el snare
                const noise = ctx.createBufferSource();
                const buffer = ctx.createBuffer(1, ctx.sampleRate * 0.1, ctx.sampleRate);
                const data = buffer.getChannelData(0);
                for(let i=0; i < buffer.length; i++) data[i] = Math.random() * 2 - 1;
                noise.buffer = buffer;
                const noiseGain = ctx.createGain();
                noiseGain.gain.value = 0.5;
                noiseGain.connect(masterGain);
                noiseGain.connect(window.fxBus);
                noise.connect(noiseGain);
                noise.start(time);
            } else { // Hihat
                // Sintesis FM simple para metálicos
                osc.type = 'square';
                osc.frequency.setValueAtTime(1200, time); // Alta frecuencia
                // Modulador FM para inarmonicidad
                /* Simplificado para rendimiento: Usar onda cuadrada corta */
                gain.gain.setValueAtTime(0.3, time);
                gain.gain.exponentialRampToValueAtTime(0.01, time + 0.05);

                // Filtro paso alto para hihat
                const hp = ctx.createBiquadFilter();
                hp.type = 'highpass';
                hp.frequency.value = 5000;
                osc.disconnect();
                osc.connect(hp);
                hp.connect(gain);
            }

            osc.start(time);
            osc.stop(time + 0.5);
        }

        function playBass(time, step) {
            // Sintetizador de Bajo FM
            const osc = ctx.createOscillator();
            const mod = ctx.createOscillator();
            const modGain = ctx.createGain();
            const masterVol = ctx.createGain();

            // Notas cambiantes según el paso (Secuencia melódica simple)
            // Escala menor básica
            const notes = [55, 55, 65, 55, 55, 55, 65, 73, 55, 55, 65, 55, 82, 73, 65, 55];
            const freq = notes[step] || 55;

            osc.type = 'sawtooth';
            osc.frequency.setValueAtTime(freq, time);

            mod.type = 'sine';
            mod.frequency.setValueAtTime(freq * 2, time); // Octava arriba
            modGain.gain.setValueAtTime(300, time); // Indice de modulación

            mod.connect(modGain);
            modGain.connect(osc.frequency);

            masterVol.gain.setValueAtTime(0.4, time);
            masterVol.gain.setTargetAtTime(0, time + 0.1, 0.2); // Decay

            osc.connect(masterVol);
            masterVol.connect(masterGain);

            osc.start(time);
            mod.start(time);
            osc.stop(time + 0.5);
            mod.stop(time + 0.5);
        }

        // --- CONSTRUCCIÓN UI SECUENCIADOR ---
        tracks.forEach(t => {
            const row = document.getElementById(`row-${t}`);
            for(let i=0; i<16; i++) {
                const step = document.createElement('div');
                step.className = `step ${pattern[t][i] ? 'on' : ''}`;
                step.id = `${t}-${i}`;
                step.onclick = () => {
                    pattern[t][i] = pattern[t][i] ? 0 : 1;
                    step.classList.toggle('on');
                };
                row.appendChild(step);
            }
        });

        // --- LOGICA DECKS (MEZCLA) ---
        const decks = { A: {}, B: {} };

        function initDecks() {
            ['A', 'B'].forEach(id => {
                decks[id].gain = ctx.createGain();
                decks[id].filter = ctx.createBiquadFilter();
                decks[id].playing = false;

                if(id === 'A') {
                    decks[id].filter.type = 'lowpass';
                    decks[id].filter.frequency.value = 22000;
                } else {
                    decks[id].filter.type = 'highpass';
                    decks[id].filter.frequency.value = 0;
                }

                decks[id].filter.connect(decks[id].gain);
                decks[id].gain.connect(masterGain);
                // Envio a FX también
                decks[id].gain.connect(window.fxBus);
            });
            crossfade(50);
        }

        function loadDeck(id, input) {
            if(!ctx) initAudio();
            const file = input.files[0];
            if(!file) return;
            const reader = new FileReader();
            reader.onload = e => {
                ctx.decodeAudioData(e.target.result, buffer => {
                    decks[id].buffer = buffer;
                });
            };
            reader.readAsArrayBuffer(file);
        }

        function toggleDeck(id) {
            if(!decks[id].buffer) return;
            if(decks[id].playing) {
                decks[id].source.stop();
                decks[id].playing = false;
            } else {
                const src = ctx.createBufferSource();
                src.buffer = decks[id].buffer;
                src.loop = true;
                src.connect(decks[id].filter);
                src.start(0);
                decks[id].source = src;
                decks[id].playing = true;
            }
        }

        function setFilter(id, val) {
            const freq = (val / 100) * 10000;
            if(id === 'A') decks[id].filter.frequency.value = freq + 50;
            else decks[id].filter.frequency.value = freq;
        }

        // --- FX CONTROL ---
        function setDelayTime(val) {
            // 0 - 100 -> 0.05s - 1.0s
            if(delayNode) delayNode.delayTime.value = 0.05 + (val/100);
        }
        function setDelayFeedback(val) {
            if(feedbackNode) feedbackNode.gain.value = val / 100;
        }
        function setDelayWet(val) {
            if(wetGainNode) wetGainNode.gain.value = val / 100;
        }

        function crossfade(val) {
            if(!decks.A.gain) return;
            const x = val / 100;
            // Equal power crossfade curve
            decks.A.gain.gain.value = Math.cos(x * 0.5 * Math.PI);
            decks.B.gain.gain.value = Math.cos((1 - x) * 0.5 * Math.PI);
        }

        function updateBPM(val) {
            bpm = val;
            document.getElementById('bpmDisplay').innerText = val;
        }

        // --- VISUALIZADOR ---
        function visualize() {
            const canvas = document.getElementById('scope');
            const cCtx = canvas.getContext('2d');
            const bufferLength = analyser.frequencyBinCount;
            const dataArray = new Uint8Array(bufferLength);

            function draw() {
                requestAnimationFrame(draw);
                analyser.getByteFrequencyData(dataArray);

                cCtx.fillStyle = '#000';
                cCtx.fillRect(0, 0, canvas.width, canvas.height);

                const barWidth = (canvas.width / bufferLength) * 2.5;
                let barHeight;
                let x = 0;

                for(let i = 0; i < bufferLength; i++) {
                    barHeight = dataArray[i] / 2;

                    // Colores Cyberpunk dinámicos
                    const r = barHeight + (25 * (i/bufferLength));
                    const g = 250 * (i/bufferLength);
                    const b = 255; // Cian base

                    cCtx.fillStyle = `rgb(${r*0.5},${g},${b})`;
                    cCtx.fillRect(x, canvas.height - barHeight, barWidth, barHeight);
                    x += barWidth + 1;
                }
            }
            draw();
        }

    </script>
</body>
</html>
